/*
 * Proyecto_Final_RTOS.h
 *
 *  Created on: 21 ago. 2021
 *      Author: Cesar
 */

#ifndef PROYECTO_FINAL_RTOS_H_
#define PROYECTO_FINAL_RTOS_H_


#include <stdio.h>
#include "board.h"
#include "peripherals.h"
#include "pin_mux.h"
#include "clock_config.h"
#include "MK64F12.h"
#include "fsl_debug_console.h"

/* TODO: insert other include files here. */

#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include "event_groups.h"
#include "queue.h"
#include "nokiaLCD.h"

/* TODO: insert other definitions and declarations here. */

#define Stack 200						/* Value Stack from tasks */
#define Alarm_Hours    1u				/* Time value in the alarm Hours*/
#define Alarm_Minutes 29u				/* Time value in the alarm Minutes */
#define Alarm_Seconds  1u				/* Time value in the alarm  Seconds*/
#define Set_Hours	   1u				/* Initial clock value Hours */
#define Set_Minutes	  28u				/* Initial clock value Minutes */
#define Set_Seconds	  56u				/* Initial clock value Seconds */
#define SECONDS_TASK_BIT ( 1UL << 0UL ) /* Event bit 0 */
#define MINUTES_TASK_BIT ( 1UL << 1UL ) /* Event bit 1 */
#define HOURS_TASK_BIT ( 1UL << 2UL )   /* Event bit 2 */
#define HOURS_MAX     24u				/* Limit value */
#define MINUTES_MAX   60u				/* Limit value */
#define SECONDS_MAX   60u				/* Limit value */
#define SIZE_QUEUE     5u				/* Queue size value */

const uint8_t Marco[] = {
  0x00, 0xf8, 0x28, 0xf0, 0xf8, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0xf8, 0xf0, 0xe8, 0xb0, 0x20, 0xd0, 0x78, 0xd0, 0xa0, 0x90, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0x70, 0x90, 0x90, 0x70, 0xe8, 0xb0, 0xc0, 0x70, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0xf0, 0xf8, 0x70, 0x80, 0xf0, 0x68, 0xb0, 0xa0, 0x90, 0x78, 0xf0, 0xf8, 0xf8, 0xf0, 0xf8, 0xf8, 0xf0, 0xf8, 0xf0, 0x48, 0xf8, 0x00,
  0x00, 0x8e, 0xdb, 0x6f, 0xdf, 0xdf, 0x3f, 0xd2, 0x0b, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x0b, 0xd6, 0x3f, 0xcf, 0xdf, 0xbf, 0x97, 0x4b, 0x00,
  0x00, 0x7c, 0xfa, 0xfd, 0xfe, 0xfe, 0xfd, 0x76, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x6c, 0xfb, 0xfd, 0xfe, 0xff, 0xfa, 0xb4, 0x00,
  0x00, 0xfb, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xbb, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd7, 0x00,
  0x00, 0xc8, 0xad, 0xf3, 0xed, 0xee, 0xf2, 0x6d, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x6c, 0xd7, 0xed, 0xed, 0xda, 0xed, 0xc0, 0x00,
  0x00, 0x7f, 0x53, 0x3f, 0x7f, 0x3f, 0x7f, 0x7d, 0x7e, 0x3e, 0x3e, 0x7c, 0x5a, 0x3c, 0x20, 0x2c, 0x5a, 0x3c, 0x28, 0x24, 0x5e, 0x3c, 0x7c, 0x7e, 0x7e, 0x3e, 0x7c, 0x3e, 0x7e, 0x7c, 0x7e, 0x3e, 0x7c, 0x7e, 0x3e, 0x7c, 0x7c, 0x7e, 0x1a, 0x2c, 0x08, 0x3c, 0x5a, 0x34, 0x04, 0x3c, 0x7e, 0x3c, 0x7e, 0x3c, 0x7e, 0x7e, 0x7e, 0x3c, 0x7e, 0x3e, 0x7e, 0x7c, 0x7e, 0x3e, 0x3c, 0x7e, 0x3c, 0x7a, 0x1c, 0x20, 0x3c, 0x5a, 0x34, 0x08, 0x34, 0x5e, 0x7c, 0x3e, 0x7c, 0x7f, 0x7d, 0x3f, 0x7f, 0x3f, 0x7f, 0x56, 0x7f, 0x00
};

const uint8_t Marco_1[] = {
  0xc7, 0xc7, 0xc7, 0xe7, 0x38, 0x3c, 0x38, 0x38, 0x38, 0xe7, 0xc7, 0xe7, 0xc7, 0xc7, 0x3c, 0x38, 0x38, 0x3c, 0x38, 0xe7, 0xc7, 0xc7, 0xe7, 0xc7, 0x3d, 0xb8, 0x38, 0xb8, 0x38, 0xe7, 0xe7, 0xc7, 0xc7, 0xc7, 0x9a, 0xb8, 0x38, 0xb8, 0x38, 0xd7, 0xc7, 0xc7, 0x67, 0x47, 0xb5, 0xb8, 0x3c, 0xb8, 0x38, 0xde, 0xe7, 0xc7, 0xc7, 0xc7, 0xef, 0x38, 0x38, 0xb8, 0xbc, 0xaa, 0xc7, 0xc7, 0xe7, 0xc7, 0x9e, 0x38, 0x38, 0x38, 0x38, 0x3a, 0xc7, 0xe7, 0xe7, 0xc7, 0xc7, 0x38, 0x38, 0x3c, 0x38, 0x38, 0xc7, 0xc7, 0xc7, 0xe7,
  0x70, 0x39, 0x78, 0x31, 0xce, 0xcf, 0x8e, 0xc7, 0x6e, 0xb9, 0xb1, 0x38, 0x79, 0x39, 0x06, 0x6e, 0x27, 0x3e, 0x2f, 0x17, 0x0b, 0x05, 0x03, 0x00, 0x02, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x05, 0x0b, 0x13, 0x27, 0x3e, 0x2f, 0x26, 0x1f, 0x30, 0x79, 0x78, 0xb1, 0xb9, 0x4f, 0xc6, 0x8f, 0xce, 0x8e, 0x79, 0x39, 0x30, 0x39,
  0x8e, 0x8e, 0x8e, 0x8e, 0x71, 0xff, 0xff, 0x00, 0x7e, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7e, 0x80, 0x3d, 0xff, 0xd7, 0x8e, 0x8e, 0x8e, 0x8e,
  0xe3, 0xe3, 0xe3, 0xf3, 0x1e, 0xfe, 0xfd, 0x02, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x02, 0xdb, 0xfd, 0x5e, 0xe3, 0xf3, 0xe3, 0xe3,
  0x3c, 0x18, 0x1c, 0x38, 0xe7, 0xe7, 0xe3, 0xe6, 0xe4, 0x1d, 0x12, 0x3c, 0x3c, 0x18, 0xe8, 0xe8, 0xe8, 0xf8, 0xe8, 0xd0, 0xa0, 0x40, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x40, 0x80, 0xa0, 0xf0, 0xc8, 0xf8, 0xd8, 0xe8, 0x68, 0x34, 0x1c, 0x3c, 0x1a, 0x3d, 0xe4, 0xc6, 0xe3, 0xe3, 0xe7, 0x38, 0x1c, 0x3c, 0x1c,
  0xc7, 0xc7, 0xc7, 0xc7, 0x39, 0x38, 0x38, 0x38, 0x38, 0xc7, 0xc7, 0xcf, 0xc7, 0xc7, 0x39, 0x38, 0x38, 0x39, 0x38, 0xc7, 0xc7, 0xc7, 0xcf, 0xc7, 0x39, 0x3b, 0x3a, 0x39, 0x39, 0xde, 0xc7, 0xc7, 0xc7, 0xc7, 0x7b, 0x38, 0x3b, 0x38, 0x39, 0xd7, 0xc6, 0xc6, 0xc4, 0xc7, 0x7a, 0x3b, 0x39, 0x39, 0x39, 0xf6, 0xc7, 0xc7, 0xc7, 0xc6, 0x7b, 0x39, 0x3b, 0x39, 0x39, 0xd7, 0xce, 0xc7, 0xc7, 0xc7, 0x6d, 0x38, 0x38, 0x38, 0x39, 0xba, 0xc7, 0xc7, 0xc7, 0xc7, 0xef, 0x38, 0x38, 0x38, 0x38, 0xb9, 0xc7, 0xc7, 0xc7, 0xc7
};


typedef struct {
	/**** Dates alarm ****/
	uint8_t alarm_second;
	uint8_t alarm_minute;
	uint8_t alarm_hour;

	/**** Set Time  ****/
	uint8_t set_second;
	uint8_t set_minute;
	uint8_t set_hour;

	/* Event Group*/
	EventGroupHandle_t xEventGroup;

	/************ Semaphores *********/
	SemaphoreHandle_t minutes_semaphore;
	SemaphoreHandle_t hours_semaphore;

}Init;

typedef enum {
	seconds_type,
	minutes_type,
	hours_type
}time_types_t;

typedef struct{
	time_types_t time_type;
	uint8_t Value;
}time_msg_t;

typedef struct {
	uint8_t units;
	uint8_t tens;
}Int_to_char;

static QueueHandle_t mailbox;

SemaphoreHandle_t Mutex;
SemaphoreHandle_t LCD;


/************ Declaration of functions *********/

Int_to_char INT_CHAR (uint8_t Num);


/************ The tasks to be created. *********/
static void seconds_task (void *args);
static void minutes_task (void *args);
static void hours_task   (void *args);
static void alarm_task   (void *args);
static void print_task   (void *args);
static void LCD_init     (void *args);




/************ Coding functions *********/


/************ Coding tasks *********/
static void seconds_task (void *args){

	Init* Init_Config = (Init*) args;
	TickType_t xLastWakeTime;
	const TickType_t xDelay1ms = pdMS_TO_TICKS(1000);
	xLastWakeTime = xTaskGetTickCount();

	time_msg_t Time_Second;
	time_msg_t *Send;

	for (;;) {


		if(Init_Config->alarm_second == Init_Config->set_second){
			xEventGroupSetBits(Init_Config->xEventGroup, SECONDS_TASK_BIT);
		}
		Init_Config->set_second++;
		Time_Second.time_type = seconds_type;
		Time_Second.Value     = Init_Config->set_second;
		Send = pvPortMalloc(sizeof(time_msg_t));
		if(SECONDS_MAX == Init_Config->set_second)
		{
			Init_Config->set_second = 0;
			Time_Second.Value     = Init_Config->set_second;
			*Send = Time_Second;
			xQueueSend(mailbox,&Send,portMAX_DELAY);
			xSemaphoreGive(Init_Config->minutes_semaphore);
		}
		else
		{
			*Send = Time_Second;
			xQueueSend(mailbox,&Send,portMAX_DELAY);
		}

		vTaskDelayUntil(&xLastWakeTime,xDelay1ms);
	}

}

static void minutes_task (void *args){

	Init* Init_Config = (Init*) args;
	time_msg_t Time_minutes;
	time_msg_t *Send;

	for(;;){

		if(Init_Config->alarm_minute == Init_Config->set_minute){
			xEventGroupClearBits(Init_Config->xEventGroup,SECONDS_TASK_BIT);
			xEventGroupSetBits(Init_Config->xEventGroup, MINUTES_TASK_BIT);
		}
		xSemaphoreTake(Init_Config->minutes_semaphore,portMAX_DELAY);
		Init_Config->set_minute++;
		Time_minutes.time_type = minutes_type;
		Time_minutes.Value     = Init_Config->set_minute;
		Send = pvPortMalloc(sizeof(time_msg_t));

		if(MINUTES_MAX <= Init_Config->set_minute)
		{
			Init_Config->set_minute = 0;
			Time_minutes.Value     = Init_Config->set_minute;
			*Send = Time_minutes;
			xQueueSend(mailbox,&Send,portMAX_DELAY);
			xSemaphoreGive(Init_Config->hours_semaphore);
		}
		else
		{
			*Send = Time_minutes;
			xQueueSend(mailbox,&Send,portMAX_DELAY);

		}
	}
}

static void hours_task   (void *args){

	Init* Init_Config = (Init*) args;
	time_msg_t Time_hours;
	time_msg_t *Send;
	for(;;){

		if(Init_Config->alarm_hour == Init_Config->set_hour){
			xEventGroupClearBits(Init_Config->xEventGroup,MINUTES_TASK_BIT);
			xEventGroupSetBits(Init_Config->xEventGroup, HOURS_TASK_BIT);
		}
		xSemaphoreTake(Init_Config->hours_semaphore,portMAX_DELAY);
		Init_Config->set_hour++;
		Time_hours.time_type = hours_type;
		Time_hours.Value     = Init_Config->set_hour;
		Send = pvPortMalloc(sizeof(time_msg_t));

		if(HOURS_MAX <= Init_Config->set_hour)
		{
			Init_Config->set_hour = 0;
			Time_hours.Value     = Init_Config->set_hour;
			*Send = Time_hours;
			xQueueSend(mailbox,&Send,portMAX_DELAY);
		}
		else
		{
			*Send = Time_hours;
			xQueueSend(mailbox,&Send,portMAX_DELAY);

		}
	}
}

static void alarm_task   (void *args){

	Init* Init_Config = (Init*) args;
	const EventBits_t xBitsToWaitFor = (SECONDS_TASK_BIT| MINUTES_TASK_BIT| HOURS_TASK_BIT);
	EventBits_t xEventGroupValue;
	const TickType_t xDelay1ms = pdMS_TO_TICKS(1000);
	char string_alarm[] = {"ALARM"};
	char string_alarm_clear[] = {"     "};

	for(;;){
		xEventGroupValue = xEventGroupWaitBits(Init_Config->xEventGroup, xBitsToWaitFor, pdTRUE,pdTRUE, portMAX_DELAY);
		if(0 != xEventGroupValue){
			xSemaphoreTake(Mutex,portMAX_DELAY);
			nokiaLCD_backlight(1);
			nokiaLCD_setStr(string_alarm, 30, 10, 1);
			nokiaLCD_updateDisplay();
			vTaskDelay(xDelay1ms);
			nokiaLCD_backlight(0);
			nokiaLCD_setStr(string_alarm, 30, 10, 0);
			nokiaLCD_updateDisplay();
			vTaskDelay(xDelay1ms);
			nokiaLCD_backlight(1);
			nokiaLCD_setStr(string_alarm, 30, 10, 1);
			nokiaLCD_updateDisplay();
			vTaskDelay(xDelay1ms);
			nokiaLCD_setStr(string_alarm_clear, 30, 10, 1);
			nokiaLCD_backlight(0);
			nokiaLCD_updateDisplay();

			xSemaphoreGive(Mutex);
		}
	}
}

static void print_task   (void *args){

	time_msg_t *Recived;
	Int_to_char Init;

	for (;;) {
		xQueueReceive(mailbox, &Recived, portMAX_DELAY);
		xSemaphoreTake(Mutex,portMAX_DELAY);
		if(Recived->time_type == seconds_type ){
			/******* Seconds centered on the LCD display *****/
			Init = INT_CHAR(Recived->Value);
			nokiaLCD_setChar(Init.tens, 60, 20, 1);
			nokiaLCD_setChar(Init.units, 68, 20, 1);
			nokiaLCD_updateDisplay();
			vPortFree(Recived);
		}
		if(Recived->time_type == minutes_type){
			/******* Minutes centered on the LCD display *****/
			Init = INT_CHAR(Recived->Value);
			nokiaLCD_setChar(Init.tens, 36, 20, 1);
			nokiaLCD_setChar(Init.units, 44, 20, 1);
			nokiaLCD_updateDisplay();
			nokiaLCD_setChar(':', 52 , 20, 1);
			vPortFree(Recived);
		}
		if(Recived->time_type == hours_type){
			/******* Hours centered on the LCD display *****/
			Init = INT_CHAR(Recived->Value);
			nokiaLCD_setChar(Init.tens, 12, 20, 1);
			nokiaLCD_setChar(Init.units, 20, 20, 1);
			nokiaLCD_updateDisplay();
			nokiaLCD_setChar(':',28 , 20, 1);
			vPortFree(Recived);
		}
		xSemaphoreGive(Mutex);
	}
}

static void LCD_init     (void *args){

	Init* Init_Config = (Init*) args;
	static Int_to_char Init;   /// Si se delclara una variable static dentro de una tarea , no se puede asegurar que el stack de esa variable este dentro del stack de la tarea

	for(;;){
	    /************ Initializing the  Nokia 5110  LCD *********/

		xSemaphoreTake(LCD,portMAX_DELAY);

		nokiaLCD_initialise();
		nokiaLCD_clearDisplay(0);
		nokiaLCD_backlight(0);
		nokiaLCD_setBitmap(&Marco_1);

		/******* Hours centered on the LCD display *****/
		Init = INT_CHAR(Init_Config->set_hour);
		nokiaLCD_setChar(Init.tens, 12, 20, 1);
		nokiaLCD_setChar(Init.units, 20, 20, 1);
		nokiaLCD_updateDisplay();
		nokiaLCD_setChar(':',28 , 20, 1);

		/******* Minutes centered on the LCD display *****/
		Init = INT_CHAR(Init_Config->set_minute);
		nokiaLCD_setChar(Init.tens, 36, 20, 1);
		nokiaLCD_setChar(Init.units, 44, 20, 1);
		nokiaLCD_updateDisplay();
		nokiaLCD_setChar(':', 52 , 20, 1);

		/******* Seconds centered on the LCD display *****/
		Init = INT_CHAR(Init_Config->set_second);
		nokiaLCD_setChar(Init.tens, 60, 20, 1);
		nokiaLCD_setChar(Init.units, 68, 20, 1);
		nokiaLCD_updateDisplay();

	}
}

Int_to_char INT_CHAR (uint8_t Num){

	Int_to_char LCD;

	if(Num <= 9){
		LCD.units = Num + 0x30;
		LCD.tens  = 0x30;
	}
	if(Num >=10 && Num <= 19){
		LCD.units = (Num - 10) + 0x30;
		LCD.tens  = 0x31;
	}
	if(Num >=20 && Num <= 29){
		LCD.units = (Num - 20) + 0x30;
		LCD.tens  = 0x32;
	}
	if(Num >=30 && Num <= 39){
		LCD.units = (Num - 30) + 0x30 ;
		LCD.tens  = 0x33;
	}
	if(Num >=40 && Num <= 49){
		LCD.units = (Num - 40) + 0x30;
		LCD.tens  = 0x34;
	}
	if(Num >=50 && Num <= 59){
		LCD.units = (Num - 50) + 0x30;
		LCD.tens  = 0x35;
	}

	return LCD;
}

#endif /* PROYECTO_FINAL_RTOS_H_ */
